# -*- coding: utf-8 -*-
"""
/***************************************************************************
 infasLtGeocoderDockWidget
                                 A QGIS plugin
  
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-09-05
        git sha              : $Format:%H$
        copyright            : (C) 2022 by infas LT GmbH
        email                : Info@infas-LT.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from cgitb import reset
import os
import time
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from pathlib import Path
from qgis import utils
from qgis.utils import iface
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets, QtCore
from qgis.core import *
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import QTextCursor
from qgis.PyQt.QtWidgets import QMainWindow, QLabel, QCheckBox, QWidget, QHBoxLayout, QComboBox, QLineEdit, QFrame, QVBoxLayout
from infas_lt_geocoder.scripts.globalFunctions import loadConfigDict
from infas_lt_geocoder.geocoder.infas_geocoder import InfasGeocoder
configName = 'globalConfig'
basePath = Path(__file__).parent.parent
configDict = loadConfigDict(configName, basePath)

locale = QSettings().value('locale/userLocale')[0:2]
locale_path = os.path.join(
    basePath,
    'i18n',
    'infasLtGeocoder_{}.qm'.format(locale))

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'infas_lt_geocoder_dockwidget_base.ui'))


class infasLtGeocoderDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(infasLtGeocoderDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.configDict = configDict
        self.globalConfig = configDict['globalConfig']
        self.iface = utils.iface
        # self.pushButtonSaveResult.setEnabled(False)
        self.pushButtonReverseGeocoding.setEnabled(False)
        if QSettings().value('locale/userLocale')[0:2] == 'de':
            self.lat.setPlaceholderText('53,16')
            self.lon.setPlaceholderText('7,59')
        else:
            self.lat.setPlaceholderText('53.16')
            self.lon.setPlaceholderText('7.59')
        self.contactLabel.setOpenExternalLinks(True)
        self.copyrightLabel.setOpenExternalLinks(True)
        self.pushButtonSingleGeocoding.clicked.connect(self.singleGeocoding)
        self.pushButtonBatchGeocoding.clicked.connect(self.batchGeocoding)
        self.pushButtonReverseGeocoding.clicked.connect(self.reverseGeocoding)
        self.license.textChanged[str].connect(self.onChanged)
        self.import_csv_button.clicked.connect(self.getData)
        #self.aboutPage.clicked.connect(self.showAbout)
        # self.pushButtonGeocoding.clicked.connect(self.startGeocoding)
        #self.pushButtonAttributeTable.clicked.connect(self.showAttributeTable)
        #self.pushButtonSaveResult.clicked.connect(self.exportCsv)
        self.layerCombo.setFilters(QgsMapLayerProxyModel.VectorLayer)
        self.layerCombo.layerChanged.connect(lambda: self.changeLayer(legend=False))
        self.singleNo = 0
        self.reverseNo = 0
        self.batchNo = 0

    # def getDetails(self, geocoding:str):
    #     self.tabWidget.setCurrentIndex(self.globalConfig['logTabIndex'])
    #     self.geocoding = geocoding

    # def startGeocoding(self):
    #     if self.geocoding == 'single':
    #         self.singleGeocoding()
    #     elif self.geocoding == 'batch':
    #         self.batchGeocoding()
    #     else:
    #         self.reverseGeocoding()

    def singleGeocoding(self):
        """
        This function support single geocoding and provides the input, i.e. street, house number, postal code and city
        to class InfasCoder
        :return: Returns a vector point layer of the address entered by the user
        """
        self.logEdit.clear()
        value = [self.strasse.text(), self.houseNr.text(), self.plz.text(), self.ort.text(), self.landEinzel_ComboBox.currentText()]
        key = self.globalConfig['payloadDictKeysSingle']
        license = self.license.text()
        self.response = self.check(value=value, geo='single')
        if self.response:
            singleGeoDict = dict(zip(key, value))
            self.singleNo += 1
            geocoder = InfasGeocoder(geoDict=singleGeoDict, license=license, layer=None, geo='single', no=self.singleNo)
            result = geocoder.geocoding()
            if type(result) == str:
                self.singleNo -= 1
                self.tabWidget.setCurrentIndex(self.globalConfig['logTabIndex'])
                if os.path.exists(locale_path):
                    self.log(result, type=Qgis.Critical)
                else:
                    self.log('Verbindungsfehler. Bitte versuchen Sie es später noch einmal', type=Qgis.Critical)
            elif not result:
                self.singleNo -= 1
                self.tabWidget.setCurrentIndex(self.globalConfig['logTabIndex'])
                if os.path.exists(locale_path):
                    self.log('Please enter valid address', type=Qgis.Critical)
                else:
                    self.log('Bitte gültige Adresse eingeben', type=Qgis.Critical)
            else:
                # self.enableButtons()
                self.zoomLayer()
                self.tabWidget.setCurrentIndex(self.globalConfig['logTabIndex'])
                if os.path.exists(locale_path):
                    self.log('Single geocoding successfully completed', type=Qgis.Info)
                else:
                    self.log('Einzel Geocodierung erfolgreich abgeschlossen', type=Qgis.Info)
                if self.checkBoxAttributeTable.isChecked():
                    self.showAttributeTable()

    def batchGeocoding(self):
        """
        This function support batch geocoding and provides the input in a .csv file, i.e. street, house number, postal
        code and city to class InfasCoder
        :return: Returns a vector point layer of all the addresses in the .csv file provided by the user
        """
        self.logEdit.clear()
        if iface.activeLayer().name() is None:
            self.tabWidget.setCurrentIndex(self.globalConfig['logTabIndex'])
            if os.path.exists(locale_path):
                self.log('Please upload a file for batch geocoding', type=Qgis.Critical)
            else:
                self.log('Bitte laden Sie eine Datei für die Batch-Geokodierung hoch', type=Qgis.Critical)
            # self.disableButtons()
        else:
            license = self.license.text()
            # lenCharacter = 0
            # lenSpecialCharacter = 0
            # for s in range(0, len(license)):
            #     if (license[s].isalpha() or license[s].isdigit()):
            #         lenCharacter += 1
            #     else:
            #         lenSpecialCharacter += 1
            if len({k: v for k, v in self.batchGeoDict.items() if v}) < self.globalConfig['minimumFieldCount']:
                self.tabWidget.setCurrentIndex(self.globalConfig['logTabIndex'])
                if os.path.exists(locale_path):
                    self.log("Please select at least two fields", type=Qgis.Critical)
                else:
                    self.log('Bitte wählen Sie mindestens zwei Felder aus', type=Qgis.Critical)
            elif self.batchGeoDict['Land'] == '':
                self.tabWidget.setCurrentIndex(self.globalConfig['logTabIndex'])
                if os.path.exists(locale_path):
                    self.log("Please select a country", type=Qgis.Critical)
                else:
                    self.log('Bitte wählen Sie ein Land', type=Qgis.Critical)
            # elif (lenSpecialCharacter != self.globalConfig['licenseKeySpecialCharacterLength'] or \
            #       lenCharacter != self.globalConfig['licenseKeyCharacterLength']):
            #     self.log('Bitte geben Sie einen Lizenzschlüssel/ gültigen Lizenzschlüssel ein', type=Qgis.Critical)
            else:
                self.batchNo += 1
                self.tabWidget.setCurrentIndex(self.globalConfig['logTabIndex'])
                time.sleep(2)
                geocoder = InfasGeocoder(geoDict=self.batchGeoDict, license=license, layer=self.layer, geo='batch', no=self.batchNo)
                result = geocoder.geocoding()
                if type(result) == str:
                    self.batchNo -= 1
                    self.tabWidget.setCurrentIndex(self.globalConfig['logTabIndex'])
                    if os.path.exists(locale_path):
                        self.log(result, type=Qgis.Critical)
                    else:
                        self.log('Verbindungsfehler. Bitte versuchen Sie es später noch einmal', type=Qgis.Critical)
                elif not result:
                    self.batchNo -= 1
                    self.tabWidget.setCurrentIndex(self.globalConfig['logTabIndex'])
                    if os.path.exists(locale_path):
                        self.log("Please check the selected labels/license keys", type=Qgis.Critical)
                    else:
                        self.log('Bitte überprüfen Sie die ausgewählten Labels/Lizenzschlüssel', type=Qgis.Critical)
                else:
                    # self.enableButtons()
                    self.zoomLayer()
                    self.tabWidget.setCurrentIndex(self.globalConfig['logTabIndex'])
                    if os.path.exists(locale_path):
                        self.log("Batch geocoding successfully completed", type=Qgis.Info)
                    else:
                        self.log('Batch Geocodierung erfolgreich abgeschlossen', type=Qgis.Info)
                    if self.checkBoxAttributeTable.isChecked():
                        self.showAttributeTable()


    def onChanged(self):
        if len (self.license.text()) == self.globalConfig['licenseKeyLength']:
            self.pushButtonReverseGeocoding.setEnabled(True)
            self.licenseLabel.setText("")
        else:
            self.pushButtonReverseGeocoding.setEnabled(False)
            if os.path.exists(locale_path):
                self.licenseLabel.setText("A license key is required for reverse geocoding")
            else:
                self.licenseLabel.setText("Für die Reverse-Geocodierung ist ein Lizenzschlüssel erforderlich")

    def reverseGeocoding(self):
        self.logEdit.clear()
        value = [self.lat.text(), self.lon.text()]
        value = [str(x) for x in value]
        if ',' in (value[0] and value[1]):
            value = [QLocale().toDouble(x)[0] for x in value]
        key = self.globalConfig['payloadDictKeysReverse']
        license = self.license.text()
        self.response = self.check(value=value, geo='reverse')
        if self.response:
            reverseGeoDict = dict(zip(key, value)) 
            self.reverseNo += 1
            geocoder = InfasGeocoder(geoDict=reverseGeoDict, license=license, layer=None, geo='reverse', no=self.reverseNo)
            result = geocoder.geocoding()
            if type(result) == str:
                    self.reverseNo -= 1
                    self.tabWidget.setCurrentIndex(self.globalConfig['logTabIndex'])
                    if os.path.exists(locale_path):
                        self.log(result, type=Qgis.Critical)
                    else:
                        self.log('Verbindungsfehler. Bitte versuchen Sie es später noch einmal', type=Qgis.Critical)
            elif not result:
                self.reverseNo -= 1
                self.tabWidget.setCurrentIndex(self.globalConfig['logTabIndex'])
                if os.path.exists(locale_path):
                    self.log('Please enter valid address/license key', type=Qgis.Critical)
                else:
                    self.log('Bitte gültige Adresse/Lizenzschlüssel eingeben', type=Qgis.Critical)
            else:
                # self.enableButtons()
                self.zoomLayer()
                self.tabWidget.setCurrentIndex(self.globalConfig['logTabIndex'])
                if os.path.exists(locale_path):
                    self.log('Reverse geocoding successfully completed', type=Qgis.Info)
                else:
                    self.log('Reverse Geocodierung erfolgreich abgeschlossen', type=Qgis.Info)
                if self.checkBoxAttributeTable.isChecked():
                    self.showAttributeTable()


        # self.response = self.check(value=value, license=license, land=self.land.text())
        # if self.response:
            # reverseGeoDict = dict(zip(key, value))
            # geocoder = InfasGeocoder(geoDict=reverseGeoDict, license=license, layer=None, batch=False)
            # result = geocoder.geocoding()
            # if result is False:
            #     self.tabWidget.setCurrentIndex(self.globalConfig['logTabIndex'])
            #     self.log('Bitte gültige Adresse eingeben', type=Qgis.Critical)
            # else:
            #     self.enableButtons()
            #     self.zoomLayer()

    def check(self, value, geo):
        if geo == 'single':
            if (value[-3] == '') and (value[-2] == ''):
                self.tabWidget.setCurrentIndex(self.globalConfig['logTabIndex'])
                if os.path.exists(locale_path):
                    self.log('Please fill in at least the City field', type=Qgis.Critical)
                else:
                    self.log('Bitte füllen Sie mindestens den Ort aus', type=Qgis.Critical)
                # self.disableButtons()
                return False
            else:
                return True
        else:
            if (value[0] == '') and (value[1] == ''):
                self.tabWidget.setCurrentIndex(self.globalConfig['logTabIndex'])
                if os.path.exists(locale_path):
                    self.log('Please fill in the fields lat and lon', type=Qgis.Critical)
                else:
                    self.log('Bitte füllen Sie die Felder lat und lon aus', type=Qgis.Critical)
                return False
            else:
                return True

    def getData(self):
        """
        This fuction provies a platform for a user to upload a file
        """
        # self.disableButtons()
        actions = self.iface.addLayerMenu().actions()
        for action in actions:
            if action.objectName() == 'mActionAddDelimitedText':
                break
        action.trigger()
        try:
            self.layerCombo.setCurrentIndex(
                self.layerCombo.findText(iface.activeLayer().name(), QtCore.Qt.MatchFixedString))
            self.changeLayer(legend=False)
        except AttributeError:
            self.tabWidget.setCurrentIndex(self.globalConfig['logTabIndex'])
            if os.path.exists(locale_path):
                self.log('Please upload a file for batch geocoding', type=Qgis.Critical)
            else:
                self.log('Bitte laden Sie eine Datei für die Batch-Geokodierung hoch', type=Qgis.Critical)

    def changeLayer(self, legend):
        """
        This fuction set up the UI for batch geocoding
        :param legend: A boolean variable to start batch geocoding directly from a .csv file uploaded by a user
        :return: Returns a UI with combo boxes containing all the columns of the .csv file.
        """
        if legend:
            self.tabWidget.setCurrentIndex(1)
            self.layerCombo.setCurrentIndex(
                self.layerCombo.findText(iface.activeLayer().name(), QtCore.Qt.MatchFixedString))
        self.layer = self.layerCombo.currentLayer()
        try:
            self.fields = [field.name() for field in self.layer.fields()]
            self.checkboxList = []
            self.comboBoxList = []
            self.stringCheckList = [[], self.globalConfig['street'], [], self.globalConfig['plz'],
                                    self.globalConfig['city'], self.globalConfig['country']]
            for i, field_name in enumerate(self.globalConfig['geocodingFields']):
                checkbox = QCheckBox()
                checkbox.setText(field_name)
                label = QLabel()
                label.setText(field_name)
                self.checkboxList.append(label)
                # combobox for user-selection of a API-keyword matching the field
                combo = QComboBox()
                combo.addItem('Select a label', None)
                if i == self.globalConfig['landIndex']:
                    text = [ele for ele in self.stringCheckList[-1] if (ele in self.fields)]
                    if len(text) != self.globalConfig['nullStatus']:
                        for key, name in enumerate(self.fields):
                            combo.addItem(name, key)
                        index = combo.findText(text[0], QtCore.Qt.MatchFixedString)
                        combo.setCurrentIndex(index)
                    else:
                        for key, name in enumerate(self.globalConfig['landList']):
                            combo.addItem(name, key)
                else:
                    for key, name in enumerate(self.fields):
                        combo.addItem(name, key)
                    text = [ele for ele in self.stringCheckList[i] if (ele in self.fields)]
                    if len(text) != self.globalConfig['nullStatus']:
                        index = combo.findText(text[0], QtCore.Qt.MatchFixedString)
                        combo.setCurrentIndex(index)
                combo.currentTextChanged.connect(self.clickCombo)
                self.comboBoxList.append(combo)
                self.clickCombo()
                self.parameterGrid.addWidget(label, i, 0)
                self.parameterGrid.addWidget(combo, i, 1)
        except AttributeError:
            pass

    def default(self):
        """
        :return: Returns default state of all the comboBox
        """
        for i in reversed(range(self.parameterGrid.count())):
            self.parameterGrid.itemAt(i).widget().setParent(None)

    def clickCombo(self):
        """
        This fucntion is called whenever a user selects an element in the combo box
        :return: Returns a list of fields/columns selected by the user for batch geocoding
        """
        self.comboList = []
        for key, com in enumerate(self.comboBoxList):
            self.comboList.append(f'{com.currentText()}'.replace('Select a label', ''))
        self.getVaraibles()

    def getVaraibles(self):
        """
        :return: Returns a dictionary of pre-defined variables in globalConfig as keys and fields/columns as values
        """
        self.checkList = self.globalConfig['geocodingFields']
        self.batchGeoDict = dict(zip(self.checkList, self.comboList))

    def showAttributeTable(self):
        """
        open the QGIS attribute table for current output layer
        """
        self.iface.showAttributeTable(iface.activeLayer())

    def exportCsv(self):
        """
        open the QGIS export dialog
        """
        self.iface.setActiveLayer(iface.activeLayer())
        actions = self.iface.layerMenu().actions()
        for action in actions:
            if action.objectName() == 'mActionLayerSaveAs':
                break
        action.trigger()

    def log(self, text: str, type: int):
        """
        :param text: A message to display in the log section
        :param type: type of a message, for example, information, warning or critical
        :return: Returns a message with pre-defined color scheme
        """
        if type == Qgis.Info:
            color = 'black'
        elif type == Qgis.Critical:
            color = 'red'
        else:
            color = 'orange'
        self.logEdit.moveCursor(QTextCursor.End)
        self.logEdit.insertHtml(
            f'<span style="color: {color}">{text}</span><br>')
        scrollbar = self.logEdit.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
        if type == Qgis.Critical:
            QgsMessageLog.logMessage(text, 'infas LT Geocoder', level=type)

    def disableButtons(self):
        self.pushButtonSaveResult.setEnabled(False)

    def enableButtons(self):
        self.pushButtonSaveResult.setEnabled(True)

    def zoomLayer(self):
        layer = iface.activeLayer()
        canvas = iface.mapCanvas()
        extent = layer.extent()
        canvas.setExtent(extent)

    def showAbout(self):
        '''
        show information about plugin in dialog
        '''
        about = Dialog(ui_file='about.ui', parent=self)
        about.version_label.setText(str('1.0'))
        about.show()    

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()
