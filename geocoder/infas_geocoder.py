
# -*- coding: utf-8 -*-
"""
/***************************************************************************
 infasGeocoder.py
                                 A QGIS plugin
 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-09-05
        git sha              : $Format:%H$
        copyright            : (C) 2022 by infas LT GmbH
        email                : Info@infas-LT.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'infas LT GmbH'
__date__ = '05/09/2022'

from audioop import reverse
from distutils.log import error
from logging import exception
import math
import pandas as pd
import itertools
from qgis.utils import iface
from pathlib import Path
from qgis.core import *
from qgis.PyQt.QtCore import *
from infas_lt_geocoder.scripts.globalFunctions import loadConfigDict, createFileString
import requests
configName = 'globalConfig'
basePath = Path(__file__).parent.parent
configDict = loadConfigDict(configName, basePath)


class InfasGeocoder():
    def __init__(self, geoDict, license, layer, geo, no):
        self.geoDict = geoDict
        self.geo = geo
        self.license = license
        self.layer = layer
        self.configDict = configDict
        self.no = no
        self.globalConfig = configDict['globalConfig']
        if self.geo == 'reverse':
            self.dataKeys = self.globalConfig['dataKeysReverse']
        else:
            self.dataKeys = self.globalConfig['dataKeys']

    def geocoding(self):
        """
        This function holds the implementation of single and batch geocoding.
            Batch geocoding:
                indexList- Contains index of the field (column number from attribute table) selected by the user
                batchGeoDF- A dataFrame with columns as fields selected by the user
                payLoadDict- A dictionary with pre-defined payload parameters as keys and self.geoDict's values as
                values
                payLoadList- A list of dictionaries with payLoadDict's keys as keys and batchGeoDF's columns as values
                payload- A dictionary for a geocoding api containing license key, country and queries (payloadList)

            Single geocoding:
                payload- A dictionary for a geocoding api containing license key, street, house number, postal code,
                city
        :return: Returns a vector point layer of the input addresses
        """
        url = 'https://geocoder.infas-lt.de/api/geocode'
        if self.geo == 'batch':
            #BATCH GEOKODIERUNG
            land = self.geoDict['Land']
            if any(ele in land for ele in self.globalConfig['landList']):
                lastElement = -1
                geoList = list(self.geoDict.values())[:lastElement]
            else:
                lastElement = ''
                geoList = list(self.geoDict.values())[:]
            self.fields = [field.name() for field in self.layer.fields()]
            indexList = []
            for field in geoList:
                try:    
                    indexList.append(self.fields.index(field))
                except ValueError:
                    pass
            features = self.layer.getFeatures()
            if self.license == '':
                provider = 'pags'
            else:
                provider = 'pagsl'
            payloadDict = dict(zip(self.globalConfig['payloadDictKeysBatch'], list(self.geoDict.values())))
            payloadDict = {k: v for k, v in payloadDict.items() if v}
            if 'id' not in payloadDict.keys():
                payloadDict['id'] = ''
            payloadDict['provider'] = ''
            payloadList = []
            batchGeoDF = pd.DataFrame(columns=list(self.fields))
            row = 0
            for feat in features:
                attrsList = []
                attrs = feat.attributes()
                if lastElement == '':
                    land = attrs[indexList[-1]]
                batchGeoDF.loc[row, batchGeoDF.columns] = attrs
                for value in range(len(payloadDict)-1):
                    if payloadDict['id'] == '':
                        attrsList.append(attrs[indexList[value]])
                        if len(attrsList) == len(payloadDict) - 2:
                            attrsList.append(row)
                            attrsList.append(provider)
                            payloadList.append(dict(zip(list(payloadDict.keys()), map(str, attrsList))))
                            break
                    else:
                        attrsList.append(attrs[indexList[value]])
                        if len(attrsList) == len(payloadDict)-1:
                            attrsList.append(provider)
                            payloadList.append(dict(zip(list(payloadDict.keys()), map(str, attrsList))))
                row += 1
            resultList = []
            for lst in range(0, math.ceil(len(payloadList) / self.globalConfig['factor']) *
                                self.globalConfig['factor'], self.globalConfig['factor']):
                payload = {"license": self.license, "defaultCountry": f"{land}",
                        "language": "de-de", "queries": payloadList[lst:lst + self.globalConfig['factor']]}
                try:
                    noResponse= False
                    res = requests.post(url, json=payload)
                except:
                    noResponse = True
                resultList.append(res.json())
            if noResponse:
                return 'Connection Error. Please try again later'
            else:
                finalResultList = []
                for r in range(0, math.ceil(len(payloadList) / self.globalConfig['factor'])):
                    finalResultList.append(resultList[r]['queryresults'])
                self.data = list(itertools.chain(*finalResultList))
                statusCount = 0
                for no in range(0, len(self.data)):
                    if self.data[no]['status'] == self.globalConfig['statusCode']:
                        statusCount += 1
                if statusCount == len(self.data):
                    return False
                else:
                    batchGeoDF.columns = "input_" + batchGeoDF.columns
                    self.load(batchGeoDF=batchGeoDF)
                    return True
        elif self.geo == 'single':
            #EINZEL GEOKODIERUNG
            payload = {'id': 1, 'street': f"{self.geoDict['strasse']}", 'housenumber': f"{self.geoDict['houseNr']}",
                       'postal': f"{self.geoDict['plz']}", 'city': f"{self.geoDict['stadt']}", 'land': f"{self.geoDict['land']}",
                       'license': f"{self.license}", 'maxresults': 10}
            try:
                noResponse= False
                response = requests.get(url, params=payload)
                self.data = (response.json())
            except:
                noResponse = True
            if noResponse:
                return 'Connection Error. Please try again later'
            else:
                self.data = self.data['queryresults']
                if self.data[0]['status'] == 1:
                    self.load(batchGeoDF=None)
                    return True
                else:
                    return False
        else:
            #REVERSE GEOKODIERUNG
            url = 'https://geocoder.infas360.de/api/geocode/reverse'
            payload = {'license': f"{self.license}", 'lat': f"{self.geoDict['lat']}", 'lon': f"{self.geoDict['lon']}", 'maxresults': 1}
            try:
                noResponse= False
                response = requests.get(url, params=payload)
                self.data = (response.json())
            except:
                noResponse = True
            if noResponse:
                return 'Connection Error. Please try again later'
            else:
                if self.data['status'] == 1:
                    self.data = self.data['queryresults']
                    self.load(batchGeoDF=None)
                    return True
                else:
                    return False
            

    def getDF(self, batchGeoDF):
        """
        :return: Returns a pandas DataFrame of all the results from .json file
        """
        details = pd.DataFrame(columns=self.dataKeys)
        row = 0
        for res in range(0, len(self.data)):
            resData = self.data[res]
            if self.geo == 'reverse':
                upperLimit = 1
            else:
                upperLimit = len(resData['results'])
            if upperLimit == 0:
                upperLimit = 1
            for d in range(0, upperLimit):
                loc = 0
                if self.geo == 'reverse':
                    infoDict = {}
                    # resData = resData | resData.pop('properties')
                    resData = {**resData, **resData.pop('properties')}
                    infoDict.update(resData)
                    for index, value in infoDict.items():
                        if index in details.columns.values:
                            details.loc[row, index] = value
                        loc += 1
                else:
                    infoDict = {'id': int(resData['id'])}
                    if len(resData['results']) != 0:
                        de = resData['results'][d]
                        # de = de | de['properties']
                        de = {**de, **de['properties']}
                        de.pop('properties')
                        infoDict.update(de)
                    for index, value in infoDict.items():
                        if index in details.columns.values:
                            details.loc[row, index] = value
                        loc += 1
                row += 1
        if self.geo == 'reverse':
            pass
        else:
            details = details.sort_values('id').reset_index(drop=True)
            quality = details['quality'].str.split(',', expand=True).fillna(0).astype(int).mean(axis=1)
            loc = 0
            for q in range(0, self.globalConfig['factor'], self.globalConfig['interval']):
                if q + self.globalConfig['interval'] == self.globalConfig['factor']:
                    quality.loc[quality[(q <= quality) & (quality <= q + self.globalConfig['interval'])].index] = \
                        self.globalConfig['qualityList'][loc]
                else:
                    quality.loc[quality[(q <= quality) & (quality < q + self.globalConfig['interval'])].index] = \
                        self.globalConfig['qualityList'][loc]
                loc += 1
            quality.loc[quality[(quality < self.globalConfig['nullStatus'])].index] = self.globalConfig['qualityList'][-1]
            quality = quality.replace(self.globalConfig['qualityDict'])
            details['Quality Mean'] = quality
        if self.geo == 'batch':
            details = pd.concat([batchGeoDF, details], axis=1, ignore_index=False)
        return details


    def getPointer(self, details):
        """
        This funcitons creates a vector point layer of the addresses from latitude and longitude stored in details
        DataFrame
        :param details: pandas DataFrame containing .json results from Geocoding API
        :return: Returns a vector point layer with an attribute table followed by a categorization of the points based
        on the quality of results
        """
        if not QgsProject.instance().mapLayersByName('OSM'):
                uri = "type=xyz&url=https://tile.openstreetmap.org/{z}/{x}/{y}.png&zmax=19&zmin=0"
                mts_layer = QgsRasterLayer(uri, 'OSM', 'wms')
                if not mts_layer.isValid():
                    print("Layer failed to load!")
                QgsProject.instance().addMapLayer(mts_layer)

        # Specify the geometry type
        if self.geo == 'single':
            self.layerName = f'Einzelgeokodierung {self.no}'
        elif self.geo == 'reverse':
            self.layerName = f'Reverse-Geokodierung_{self.no}'
        else:
            self.layerName = 'Batch-Geokodierung' + f'_{self.no}'
        layer = QgsVectorLayer('Point?crs=epsg:4326', self.layerName, 'memory')
        
        # Set the provider to accept the data source
        prov = layer.dataProvider()
        # Add a new feature and assign the geometry
        feat = QgsFeature()
        # creating a new point layer
        for number in range(0, len(details['lat'])):
            feat.setGeometry(
                QgsGeometry.fromPointXY(QgsPointXY(details.loc[number, 'lon'], details.loc[number, 'lat'])))
            prov.addFeatures([feat])
        
        # Update extent of the layer
        layer.updateExtents()
        
        # Add the layer to the Layers panel
        QgsProject.instance().addMapLayers([layer])
        
        streetLayer = QgsProject.instance().mapLayersByName(self.layerName)
        streetLayer = streetLayer[0]
        streetLayerProvider = streetLayer.dataProvider()
        
        # added fields to attribute table
        for d in range(0, len(details.columns)):
            if details.columns[d] == 'id':
                streetLayerProvider.addAttributes([QgsField(f"{details.columns[d]}", QVariant.Int)])
            elif details.columns[d] == 'lat' or details.columns[d] == 'lon':
                streetLayerProvider.addAttributes([QgsField(f"{details.columns[d]}", QVariant.Double)])
            else:
                streetLayerProvider.addAttributes([QgsField(f"{details.columns[d]}", QVariant.String)])
        streetLayer.updateFields()

        # adding values to attribute table
        streetLayer.startEditing()
        row = 0
        for f in streetLayer.getFeatures():
            id = f.id()
            for fea in range(0, len(streetLayer.fields().names())):
                value = details.iloc[row, fea]
                attrValue = {fea: value}
                streetLayerProvider.changeAttributeValues({id: attrValue})
            row += 1
        streetLayer.commitChanges()


    def categorizeSteetLayer(self):
        """
        :return: Returns a categorized layer based on the results from Geocoder API
        """
        layer = iface.activeLayer()
        field = layer.fields().lookupField('Quality Mean')
        unique_values = layer.uniqueValues(field)
        unique_values = list(unique_values)
        unique_values = sorted(unique_values)
        unique_values.reverse()
        categories = []
        for value in unique_values:
            symbol = QgsSymbol.defaultSymbol(layer.geometryType())
            category = QgsRendererCategory(value, symbol, str(value))
            categories.append(category)
        myStyle = QgsStyle().defaultStyle()
        ramp = myStyle.colorRamp('YlOrRd')
        renderer = QgsCategorizedSymbolRenderer('Quality Mean', categories)
        renderer.updateColorRamp(ramp)
        layer.setRenderer(renderer)
        layer.triggerRepaint()


    def load(self, batchGeoDF):
        self.details = self.getDF(batchGeoDF=batchGeoDF)
        self.getPointer(details=self.details)
        if self.geo == 'reverse':
            pass
        else:
            self.categorizeSteetLayer()
